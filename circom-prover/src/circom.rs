use std::{
    collections::HashMap,
    fs::{canonicalize, create_dir_all, File},
    io::{Error, Write},
    process::Command,
};

use rug::{ops::Pow, Float};
use winterfell::{
    crypto::hashers::Poseidon,
    math::{fields::f256::BaseElement, log2, StarkField},
    Air, HashFunction, Prover,
};

use crate::{json::proof_to_json, WinterPublicInputs};

/// Verify a circom proof.
///
/// Requires the `verification_key.json`, `proof.json` and `public.json` files
/// to be present in the directory `target/circom/<circuit_name>`. These files
/// can be generated by the [circom_prove] function.
///
/// TODO: handle and return error
/// TODO: check for files before running snarkjs
/// TODO: verbose (print snarkjs output) and very verbose (snarkjs verbose mode)
pub fn circom_verify(circuit_name: &str) {
    assert!(Command::new("snarkjs")
        .arg("g16v")
        .arg("verification_key.json")
        .arg("public.json")
        .arg("proof.json")
        .current_dir(format!("target/circom/{}", circuit_name))
        .status()
        .unwrap()
        .success());
}

/// Prepare verification of a Winterfell proof by a Circom circuit.
///
/// - Generate the proof
/// - (Not in release mode) Verify the proof
/// - Parse the proof into a Circom-compatible JSON object
/// - Print the JSON proof to a file
/// - Generate Circom code containing the parameters of the verification
///
/// TODO: handle and return error
/// TODO: check for files (incl final.ptau) before running commands
/// TODO: verbose (print snarkjs/circom output) and very verbose (snarkjs/circom verbose mode)
pub fn circom_prove<P>(prover: P, trace: <P as Prover>::Trace, circuit_name: &str)
where
    P: Prover<BaseField = BaseElement>,
    <<P as Prover>::Air as Air>::PublicInputs: WinterPublicInputs,
{
    // BUILD PROOF
    // ===========================================================================

    assert_eq!(prover.options().hash_fn(), HashFunction::Poseidon);

    let pub_inputs = prover.get_pub_inputs(&trace);
    let proof = prover.prove(trace).unwrap();

    // VERIFY PROOF
    // ===========================================================================

    #[cfg(debug_assertions)]
    assert!(
        winterfell::verify::<P::Air>(proof.clone(), pub_inputs.clone()).is_ok(),
        "invalid proof"
    );

    // BUILD JSON OUTPUTS
    // ===========================================================================

    // retrieve air and proof options
    let air = P::Air::new(
        proof.get_trace_info(),
        pub_inputs.clone(),
        proof.options().clone(),
    );

    // convert proof to json object
    let mut fri_num_queries = Vec::new();
    let mut fri_tree_depths = Vec::new();
    let json = proof_to_json::<P::Air, Poseidon<BaseElement>>(
        proof,
        &air,
        pub_inputs.clone(),
        &mut fri_num_queries,
        &mut fri_tree_depths,
    );

    // print json to file
    let json_string = format!("{}", json);
    create_dir_all(format!("target/circom/{}", circuit_name)).unwrap();
    let mut file = File::create(format!("target/circom/{}/input.json", circuit_name)).unwrap();
    file.write(&json_string.into_bytes()).unwrap();

    // CIRCOM MAIN
    // ===========================================================================

    generate_circom_main::<P::BaseField, P::Air>(
        circuit_name,
        &air,
        &fri_num_queries,
        &fri_tree_depths,
        json["pub_coin_seed"].as_array().unwrap().len(),
    )
    .unwrap();

    // compile circom and generate witness
    assert!(
        Command::new(canonicalize("iden3_circom/target/release/circom").unwrap())
            .arg("--r1cs")
            .arg("--c")
            .arg("verifier.circom")
            .current_dir(format!("target/circom/{}", circuit_name))
            .status()
            .unwrap()
            .success()
    );

    assert!(Command::new("make")
        .current_dir(format!("target/circom/{}/verifier_cpp", circuit_name))
        .status()
        .unwrap()
        .success());

    assert!(Command::new(
        canonicalize(format!(
            "target/circom/{}/verifier_cpp/verifier",
            circuit_name
        ))
        .unwrap()
    )
    .arg("input.json")
    .arg("witness.wtns")
    .current_dir(format!("target/circom/{}", circuit_name))
    .status()
    .unwrap()
    .success());

    // generate circuit key
    assert!(Command::new("snarkjs")
        .arg("g16s")
        .arg("verifier.r1cs")
        .arg("../../../final.ptau")
        .arg("verifier_0000.zkey")
        .current_dir(format!("target/circom/{}", circuit_name))
        .status()
        .unwrap()
        .success());

    // TODO: make it work for Windows as well
    assert!(Command::new("snarkjs")
        .arg("zkc")
        .arg("verifier_0000.zkey")
        .arg("verifier_0001.zkey")
        .arg("-e=$(head/dev/urandom | tr -dc a-zA-Z0-9 | head -c 25)")
        .current_dir(format!("target/circom/{}", circuit_name))
        .status()
        .unwrap()
        .success());

    assert!(Command::new("snarkjs")
        .arg("zkev")
        .arg("verifier_0001.zkey")
        .arg("verification_key.json")
        .current_dir(format!("target/circom/{}", circuit_name))
        .status()
        .unwrap()
        .success());

    // generate snark proof
    assert!(Command::new("snarkjs")
        .arg("g16p")
        .arg("verifier_0001.zkey")
        .arg("witness.wtns")
        .arg("proof.json")
        .arg("public.json")
        .current_dir(format!("target/circom/{}", circuit_name))
        .status()
        .unwrap()
        .success());

    println!("\x1b[32m{}\x1b[0m", "Proof generated successfully!");
    println!(
        "Proof file:        {}",
        canonicalize(format!("target/circom/{}/proof.json", circuit_name))
            .unwrap()
            .to_string_lossy()
    );
    println!(
        "Verification key:  {}",
        canonicalize(format!(
            "target/circom/{}/verification_key.json",
            circuit_name
        ))
        .unwrap()
        .to_string_lossy()
    );
    println!(
        "Public in/outputs: {}",
        canonicalize(format!("target/circom/{}/public.json", circuit_name))
            .unwrap()
            .to_string_lossy()
    );
}

/// Generate a circom main file that defines the parameters for verifying a proof.
///
/// The main file is generated in the `target/circom/<circuit_name>/` directory,
/// with the `verifier.circom` name.
pub fn generate_circom_main<E, AIR>(
    circuit_name: &str,
    air: &AIR,
    fri_num_queries: &Vec<usize>,
    fri_tree_depths: &Vec<usize>,
    pub_coin_seed_len: usize,
) -> Result<(), Error>
where
    E: StarkField,
    AIR: Air,
    AIR::PublicInputs: WinterPublicInputs,
{
    let fri_num_queries = format!(
        "[{}]",
        fri_num_queries
            .iter()
            .map(|x| format!("{}", x))
            .collect::<Vec<_>>()
            .join(", ")
    );
    let fri_tree_depths = format!(
        "[{}]",
        fri_tree_depths
            .iter()
            .map(|x| format!("{}", x))
            .collect::<Vec<_>>()
            .join(", ")
    );

    let mut file = File::create(format!("target/circom/{}/verifier.circom", circuit_name))?;

    let arguments = format!(
        "{}, // addicity\n    \
            {}, // ce_blowup_factor\n    \
            {}, // domain_offset\n    \
            {}, // folding_factor\n    \
            {}, // fri_num_queries\n    \
            {}, // fri_tree_depth\n    \
            {}, // grinding_factor\n    \
            {}, // lde_blowup_factor\n    \
            {}, // num_assertions\n    \
            {}, // num_draws\n    \
            {}, // num_fri_layers\n    \
            {}, // num_pub_coin_seed\n    \
            {}, // num_public_inputs\n    \
            {}, // num_queries\n    \
            {}, // num_transition_constraints\n    \
            {}, // trace_length\n    \
            {},  // trace_length\n    \
            {} // tree_depth",
        E::TWO_ADICITY,
        air.ce_blowup_factor(),
        air.domain_offset(),
        air.options().to_fri_options().folding_factor(),
        fri_num_queries,
        fri_tree_depths,
        air.options().grinding_factor(),
        air.options().blowup_factor(),
        air.context().num_assertions(),
        number_of_draws(
            air.options().num_queries() as u128,
            air.lde_domain_size() as u128,
            128
        ),
        air.options()
            .to_fri_options()
            .num_fri_layers(air.lde_domain_size()),
        pub_coin_seed_len,
        AIR::PublicInputs::NUM_PUB_INPUTS,
        air.options().num_queries(),
        air.context().num_transition_constraints(),
        air.trace_length(),
        air.trace_info().width(),
        log2(air.lde_domain_size()),
    );

    let file_contents = format!(
        "pragma circom 2.0.0;

include \"../../../circuits/verify.circom\";
include \"../../../circuits/air/{}.circom\";

component main {{public [ood_frame_constraint_evaluation, ood_trace_frame]}} = Verify(
    {}
);
",
        circuit_name, arguments
    );

    file.write(file_contents.as_bytes())?;

    Ok(())
}

// HELPER FUNCTIONS
// ===========================================================================

fn number_of_draws(num_queries: u128, lde_domain_size: u128, security: i32) -> u128 {
    let mut num_draws: u128 = 0;
    let precision: u32 = security as u32 + 2;

    while {
        let st = step(
            0,
            num_draws,
            &mut HashMap::new(),
            num_queries,
            lde_domain_size,
            security,
        );
        num_draws += 1;
        1 - st > Float::with_val(precision, 2_f64).pow(-security)
    } {}

    num_draws
}

fn step(
    x: u128,
    n: u128,
    memo: &mut HashMap<(u128, u128), Float>,
    num_queries: u128,
    lde_domain_size: u128,
    security: i32,
) -> Float {
    let precision: u32 = security as u32 + 2;
    match memo.get(&(x, n)) {
        Some(val) => val.clone(),
        None => {
            let num: Float;
            if x == num_queries {
                num = Float::with_val(precision, 1f64);
            } else if n == 0 {
                num = Float::with_val(precision, 0f64);
            } else {
                let a = step(x + 1, n - 1, memo, num_queries, lde_domain_size, security);
                let b = step(x, n - 1, memo, num_queries, lde_domain_size, security);
                num = Float::with_val(precision, lde_domain_size - x)
                    / (Float::with_val(precision, lde_domain_size))
                    * a
                    + Float::with_val(precision, x) / (Float::with_val(precision, lde_domain_size))
                        * b;
            }
            memo.insert((x, n), num.clone());
            num
        }
    }
}
